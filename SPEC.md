# Commit History Analyzer

## 1. Overview

This application is a command-line tool to analyze the cost/benefit of using AI to generate commit and Pull Request merge messages. It interacts with GitHub repositories, processes pull requests, and uses the Gemini CLI for AI-powered analysis.

## 2. Tech Stack

*   **Language:** Go (latest stable version)
*   **CLI Framework:** Cobra
*   **AI Integration:** Gemini CLI (assumed to be in the system's PATH)
*   **Version Control:** Git (assumed to be in the system's PATH)

## 3. Authentication

The application will authenticate with the GitHub API using a Personal Access Token (PAT). The PAT must be provided via the environment variable `GITHUB_PERSONAL_ACCESS_TOKEN`.

## 4. CLI Commands

The application will expose three commands: `fetch`, `augment`, and `analyze`.

### 4.1. `fetch`

This command retrieves pull request data from a GitHub repository and saves it to a CSV file.

**Usage:**

```bash
commit-history fetch --repo <repository-url> --query "<pull-request-query>"
```

**Output CSV Naming Convention:**

The output file will be named `[repository-name]-fetched.csv`. For example, for the repository `googleapis/google-cloud-ruby`, the file will be `google-cloud-ruby-fetched.csv`.

**CSV Columns:**

1.  `pr_number`: The pull request number.
2.  `before_merge_commit_hash`: The commit hash of the PR branch before merging.
3.  `after_merge_commit_hash`: The commit hash after the PR was merged.
4.  `pr_title`: The title of the pull request.
5.  `pr_body`: The body of the first message of the pull request.
6.  `is_squash_merge`: A boolean indicating `true` if the PR was squash-merged, `false` otherwise.
7.  `merge_commit_title`: The title of the merge commit in the destination branch.
8.  `merge_commit_body`: The body of the merge commit in the destination branch.
9.  `source_link`: The `Source-Link` URL pointing to the `googleapis/googleapis` repository.
10. `resolved_source_link`: The fully resolved URL for the `Source-Link` commit.
11. `source_link_unidiff`: A unidiff representation of the changes from the `source_link` commit.

### 4.2. `augment`

This command takes the CSV file generated by `fetch`, clones the repository, and uses the Gemini CLI to generate a proposed commit message for each pull request.

**Usage:**

```bash
commit-history augment --repo <repository-url> --input-csv <path-to-fetched-csv>
```

**Output CSV Naming Convention:**

The output file will be named `[repository-name]-augmented.csv`.

**CSV Columns:**

This file will contain all columns from the `fetched` CSV, plus two new columns:

12. `gemini_proposed_title`: The commit title proposed by the Gemini CLI.
13. `gemini_proposed_body`: The commit body proposed by the Gemini CLI.

### 4.3. `analyze`

This command takes the CSV file from `augment` and uses the Gemini CLI to compare the original merge commit message with the one generated by the `augment` command.

**Usage:**

```bash
commit-history analyze --input-csv <path-to-augmented-csv>
```

**Output CSV Naming Convention:**

The output file will be named `[repository-name]-analyzed.csv`.

**CSV Columns:**

This file will contain all columns from the `augmented` CSV, plus one new column:

14. `gemini_analysis`: The result of the comparison, indicating which commit message Gemini found more comprehensive and accurate.

## 5. Implementation Details

### 5.1. Determining Merge Type

To determine if a pull request was squash-merged or rebase-merged, the application will check if the commit hashes from the PR's history are present in the target branch. If they are not, it's a squash merge.

### 5.2. Handling "Source-Link"

The application will parse the pull request body to find `Source-Link` entries that point specifically to the `googleapis/googleapis` repository. It will then resolve this link to a full commit URL and generate a unidiff of the changes.

### 5.3. Gemini CLI Interaction

For each call to the Gemini CLI, the application will:
1.  Create a temporary, isolated directory.
2.  Prepare the necessary files and context for the Gemini CLI within that directory.
3.  Execute the `gemini` command non-interactively.
4.  Clean up the temporary directory after the execution is complete.

## 6. Error Handling and Resumption

If a command is interrupted, it will save the partial results to the corresponding CSV file. When the command is re-run, it will detect the existing file and resume processing from where it left off, skipping any rows that have already been successfully processed.

## 7. Project Structure

The initial project structure will be as follows:

```
commit-history/
├── cmd/
│   ├── fetch.go
│   ├── augment.go
│   └── analyze.go
├── internal/
│   ├── csv.go
│   ├── gemini.go
│   ├── git.go
│   └── github.go
├── go.mod
├── go.sum
└── main.go
```
