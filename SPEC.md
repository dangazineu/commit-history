# Commit History Analyzer
This application is a helper tool to analyse the cost/benefit of using AI to provide commit and Pull Request merge messages.

This is a temporary application specification file, intended to describe what the application is supposed to do. Once the application has met this specification, this file can be deleted and replaced by documentation of what the application actually does.

## Tech Stack
This application will be written using the latest stable version of Go. 
It will delegate AI tasks to the [Gemini CLI](https://github.com/google-gemini/gemini-cli) using non-interactive mode.
The application will be a CLI, with different commands. Use the Cobra library to implement that.

## Functionality
The first command will be given a GitHub repository url, like "git@github.com:googleapis/google-cloud-ruby.git", and a Pull Request query, similar to "is:pr created:2024-01-01..2024-12-31 label:owl-bot-copy". It will then create a csv file, where each line will represent one of the pull requests returned by the query. 
Non-merged pull requests should be skipped, regardless of the query.

The columns should include: 
- the commit hash in the repository branch where the PR was opened (i.e: the state of the repo before merging the PR); 
- the commit hash of the repo after the PR was merged;
- the title of the pull request
- the body of the first message of the pull request;
- a boolean indicating true if squash merged or false if rebase merged;
- the title of the commit message in the destination repo;
- the body of the commit message in the destination repo;
- the source-link to googleapis/googleapis repository, if present in the body of the pull request (i.e. "Source-Link: googleapis/googleapis@5546362")
- the resolved source link to googleapis/googleapis repository (i.e. "https://github.com/googleapis/googleapis/commit/5546362a78d82f8307eb1af4b2ac178a90cd9271" for the link above)
- a unidiff representation of the changes in the commit linked by the source-link; 

The second command should take the repository url and this csv as a parameter. 
It should then clone the repository, and for each row in the CSV, it should give the Gemini CLI the state of the 
repository as of the pull request, the PR title and body, the googleapis diff, and ask Gemini CLI to provide its 
proposed merge commit title and body. The proposed commit should follow conventional commits standard, and describe how 
the changes to the API (in googleapis/googleapis) affects that specific client library. Note that sometimes, a feature 
change in an API may only result in a documentation change in the library, so the prompt should explain that and ensure 
the resulting commit is relevant to the library. 
The execution of this command should result in a new CSV file being created, with all original values of the CSV file 
that it was given, plus two new columns, one for Gemini CLI's proposed commit title, and another for the proposed commit message. 

Finally, the third command should take the csv file generated by the second command, and for each line it should make a call to Gemini CLI giving it the state of the repo before the commit, the title and body of the actual commit message, and the title and body of the commit message proposed by Gemini (it shouldn't tell Gemini that the message was proposed by it). It should then ask gemini to tell which commit message was more comprehensive and accurately described the changes to the library. The result should be stored in another CSV file containing all the original columns as well.

## Q&A
- Q: Why use Gemini CLI instead of the Gemini API directly?
- A: Because the CLI is integrated with tools, so we can provide it a much higher level task and let it figure out how to implement it. At the same time, however, we need to provide it with a proper sandboxed environment and file system space so it can work without interfering with the script or potentially other instances of the CLI that we may decide to run in parallel. 